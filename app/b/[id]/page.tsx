/**
 * @fileoverview Build detail page - displays single or team builds
 * @module app/b/[id]/page
 *
 * Server Component that fetches and displays a complete build.
 * Handles both single-character and team (8-hero) builds.
 * Increments view count on each page load.
 *
 * Route: /b/[id] where id is a 7-character nanoid
 *
 * @see lib/services/builds.ts for data fetching
 * @see components/build/ for UI components
 */
import { notFound } from 'next/navigation'
import { headers } from 'next/headers'
import type { Metadata } from 'next'
import {
  getBuildById,
  recordBuildView,
  hasUserStarredBuild,
} from '@/lib/services/builds'
import { getSkillsByIds, type Skill } from '@/lib/gw/skills'
import { createClient } from '@/lib/supabase/server'
import { PROFESSION_COLORS, SITE_URL } from '@/lib/constants'
import { BuildPageClient } from './client'
import type { SkillBar } from '@/types/database'

interface BuildPageProps {
  params: Promise<{ id: string }>
}

/**
 * Generates dynamic metadata for build pages
 *
 * Called by Next.js at request time to populate <head> tags.
 * Fetches build data (cached/deduped with page fetch).
 *
 * OG images are dynamically generated by opengraph-image.tsx
 */
export async function generateMetadata({
  params,
}: BuildPageProps): Promise<Metadata> {
  const { id } = await params
  const build = await getBuildById(id)

  if (!build) {
    return {
      title: 'Build not found',
    }
  }

  // Build description based on build type
  const isSingleBuild = build.bars.length === 1
  const professionPart = isSingleBuild
    ? `${build.bars[0].primary}${build.bars[0].secondary !== 'None' ? `/${build.bars[0].secondary}` : ''}`
    : build.bars
        .slice(0, 3)
        .map(bar => bar.primary)
        .join(', ') +
      (build.bars.length > 3 ? ` +${build.bars.length - 3}` : '')

  const description = isSingleBuild
    ? `${professionPart} build`
    : `${build.bars.length}-character team: ${professionPart}`

  // Bump version to invalidate CDN cache when OG image design changes
  const ogImageUrl = `${SITE_URL}/api/og/${build.id}?v=3`
  const pageUrl = `${SITE_URL}/b/${build.id}`

  return {
    title: build.name,
    description,
    openGraph: {
      title: build.name,
      description,
      type: 'article',
      url: pageUrl,
      siteName: 'GW1 Builds',
      images: [{ url: ogImageUrl, width: 1200, height: 630 }],
    },
    twitter: {
      card: 'summary_large_image',
      title: build.name,
      description,
      images: [ogImageUrl],
    },
  }
}

/**
 * Collects all skill IDs from build bars and fetches skill data
 */
async function getSkillsForBuild(
  bars: SkillBar[]
): Promise<Map<number, Skill>> {
  // Collect all unique skill IDs
  const skillIds = new Set<number>()
  for (const bar of bars) {
    for (const id of bar.skills) {
      if (id > 0) skillIds.add(id)
    }
  }

  // Convert to array once (not on every iteration)
  const skillIdsArray = Array.from(skillIds)

  // Fetch all skills
  const skills = await getSkillsByIds(skillIdsArray)
  const skillMap = new Map<number, Skill>()

  skillIdsArray.forEach((id, index) => {
    const skill = skills[index]
    if (skill) {
      skillMap.set(id, skill)
    }
  })

  return skillMap
}

/**
 * Build detail page component
 *
 * Async Server Component that:
 * 1. Fetches build data by ID
 * 2. Shows 404 if not found
 * 3. Fetches skill data (icons served locally from /public/skills/)
 * 4. Increments view count (fire-and-forget)
 * 5. Checks ownership for edit button
 * 6. Renders appropriate view (single vs team)
 */
export default async function BuildPage({ params }: BuildPageProps) {
  const { id } = await params

  const build = await getBuildById(id)

  if (!build) {
    notFound()
  }

  // Get client IP for unique view tracking
  const headersList = await headers()
  const clientIP =
    headersList.get('x-forwarded-for')?.split(',')[0]?.trim() ||
    headersList.get('x-real-ip') ||
    'unknown'

  // Run independent operations in parallel
  const [skillMap, supabase] = await Promise.all([
    getSkillsForBuild(build.bars as SkillBar[]),
    createClient(),
  ])

  // Get user (required for isOwner and star check)
  const {
    data: { user },
  } = await supabase.auth.getUser()

  // Record view - fire and forget (don't block render)
  recordBuildView(id, clientIP).catch(() => {})

  const isOwner = user?.id === build.author_id

  // Check if user has starred this build
  const initialStarred = user ? await hasUserStarredBuild(user.id, id) : false

  return (
    <BuildPageClient
      build={build}
      skillMap={Object.fromEntries(skillMap)}
      isOwner={isOwner}
      professionColors={PROFESSION_COLORS}
      initialStarred={initialStarred}
      starCount={build.star_count}
      isAuthenticated={!!user}
    />
  )
}
